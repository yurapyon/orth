"todo" open-input-file unwrap
{ read-line,p } keep
{ read-line,p } keep
{ read-line,p } keep
{ read-line,p } keep
clear-stack

; "file" open-output-file unwrap
; {  swap display,p } keep

{ :char :lock } :cell @record

{ { { cell.lock "[" " " ? } dip display,p }
  { { cell.char }           dip display,p }
  { { cell.lock "]" " " ? } dip display,p }
  2tri
  }
%cell record-type.display-fn!

{ make-cell } :<cell> @

{ dup pick >=
  { 3drop }
  { { { eval } keep } 2dip
    1 + do-n' }
  if
} :do-n' @
; q do-ct n

{ swap 0 do-n' } :do-n @

{ :vec
  :width
  :height
} :field @record

{ 2dup * <vec>,capacity swap
  { { #\* #f <cell> swap vpush! } keep } do-n
} :<field> @

5 5 <field> display newline

newline
"hey whats up" display newline
#\C #f make-cell display newline
#\F #t make-cell display newline


; read-line .stack'




{

{ bi* } :bis @

#\space 32 { char>int } { int>char } bis
.stack'

; is there a way to define private words this way

{
  { } :make @
  { make } :make,v2 @
  { } :get @
  { } :set @
} :&vec @

{ { :rename :make :make-vec }
  { :prefix :* :v }
} set-renaming-rules!
&vec
clear-renaming-rules!

{ rules ...  }
:&vec import

{ :a
  :b
  :c
  :d
  { :e 100 }
} :thing @enum

{ { { dup thing.a = } { } }
  { { dup thing.b = } { } }
  { { dup thing.c = } { } }
  { { dup thing.d = } { } }
  { }
} cond

{ { thing.a { } }
  { thing.b { } }
  { thing.c { } }
  { thing.d { } }
  { }
} case

} drop
