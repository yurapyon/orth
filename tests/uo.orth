{ 0 ~ swap << ~
} :gen-bitmask @

{ #x1 &
} :last-bit @

{ { 1 >> } { last-bit } bi
} :chop-bit @

{ 1 << |
} :append-bit @

{ #xff &
} :last-byte @

{ { 8 >> } { last-byte } bi
} :chop-byte @

{ pick 0 =
  { 2nip }
  { { 1 - }
    { chop-bit }
    { append-bit }
    tri*
    reverse-bits'
  }
  if
} :reverse-bits' @

{ 0 reverse-bits'
} :reverse-bits
"( int-len int -- reversed )"
@doc

{ over 0 =
  { 2nip }
  { over last-bit 1 =
    { { chop-bit }
      { 1 >> swap }
      { append-bit }
      tri*
      bitwise-merge' }
    { { }
      { 1 >> }
      { 1 << }
      tri*
      bitwise-merge' }
    if
  }
  if
} :bitwise-merge' @

{ { nip integer-length }
  { 0 bitwise-merge' }
  2bi
  reverse-bits
} :bitwise-merge
"( value mask -- )"
@doc

{ pick 0 =
  { 2nip }
  { { 1 - }
    { chop-byte }
    { { vpush! } keep }
    tri*
    int>bytes' }
  if
} :int>bytes' @

{ over <vec>,capacity int>bytes' { vreverse! } keep
} :int>bytes
"( n int -- vec )"
@doc

;;

{ 1 0 ?
} :boolean>int @

{ 0
  { { 1 << } { boolean>int } bi* | }
  fold!
} :booleans>int @

{ :base :args }a :opdef @record

; TODO fix this
{ ; spec-string > int
  { { string-iter
      { #\1 eq? } map
      booleans>int } keep } dip

  ; spec-string arg-order > vec of arguments
  { always } { string-iter } bi* zip
  { { string-iter } { always } bi* zip
    { eq? } map
    booleans>int
  }
  map
  vcollect!

  make-opdef
} :<opdef>
"( spec-string arg-order -- )"
@doc

{ { opdef-args vec-iter zip
    { bitwise-merge } map
    0 { | } fold!
    }
  { opdef-base } bi
  |
} :opdef-apply @

;#b01 #b1100 bitwise-merge
;#b10 #b0011 bitwise-merge

[ #b01 #b10 ]vec vec-iter
"0011aabb" "ab" <opdef>
opdef-apply

#b00110110

.stack

