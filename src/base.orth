; TODO
;   add more documentation
;   @alias
;     { ref unwrap } dip @
;   rename bi* bi^ to bis and bia
;   scollect!
;   return stack accessors
;   over can be written like { dup } dip swap
;     pick can probably be done like this too
;   cleave
;   fold! is well defined like each!

{ over value-type-of :slice eq? def } :@ #t def
{ #f def } :@value @

<map> :doc-table @
{ doc-table mset! } :doc! @
{ doc-table mget* "docstring not found" unwrap,default } :doc @

{ over doc! @ } :@doc @
"( value symbol doc-string -- )\ndefine with a doc string" :@doc doc!

{ { symbol>string display } keep
  ": " display
  ; todo ref display should be ref write
  { ref drop display } keep newline
  doc display newline
} :.doc
"( symbol -- )\nprint documentation for a word"
@doc

; TODO
; { over value-type-of :ffi-ptr eq?
  ; { over ffi-type-of :record eq?
    ; { over record-type-of :callable eq?
      ; ; what to do here ?
      ; { { callable-data } { callable-q eval,restore } bi }
      ; { eval,restore' }
      ; if }
    ; { eval,restore' }
    ; if }
  ; { eval,restore' }
  ; if }
; } :eval,restore @

{ ; TODO
{ dup value-type-of :ffi-ptr eq?
  { dup ffi-type-of :record eq?
    { dup record-type-of :callable eq?
      { { callable-data } { callable-q eval } bi }
      { eval' }
      ? eval' }
    { eval' }
    ? eval' }
  { eval' }
  ? eval'
} :eval @
} drop

{ eval' } :eval @

{ ref unwrap eval
} :exec
"( symbol -- )\nevaluate a symbol"
@doc

; =====

{ "\n" display
} :newline
"( -- )\ndisplay a newline"
@doc

{ "TOP| " display 0 stack-index display newline
} :.
"( x -- )\ndisplay the top of the stack"
@doc

{ "STACK| len: " display stack-len display newline
  stack-iter
  { { "    " display display "| " display } keep
    2 + stack-index display newline }
  each!
} :.stack
"( -- )\ndisplay the stack"
@doc

; =====

{ over over
} :2dup
"( x y -- x y x y )"
@doc

{ pick pick pick
} :3dup
"( x y z -- x y z x y z )"
@doc

"( x -- )\npop a value off the stack" :drop doc!

{ drop drop
} :2drop
"( x y -- )\npop two values off the stack"
@doc

{ drop drop drop
} :3drop
"( x y z -- )\npop three values off the stack"
@doc

{ { drop } dip
} :nip
"( x y z -- x z )\nremove the second from the top value from the stack"
@doc

{ { 2drop } dip
} :2nip
"( x y z -- z )\nremove the second and third from the top values from the stack"
@doc

{ pick pick
} :2over @

{ { swap } dip swap
} :rot< @

{ swap { swap } dip
} :rot> @

; =====

{ swap >restore 1 eval,restore
} :dip
"( x q -- x )\nremove x from the stack. eval q. then restore x to the stack"
@doc

{ swap { dip } dip
} :2dip
"( x y q -- x y )\nremove x and y from the stack. eval q. then restore x and y to the stack"
@doc

{ swap { 2dip } dip
} :3dip
"( x y z q -- x y z )\nremove x, y, and z from the stack. eval q. then restore x, y, and z to the stack"
@doc

{ swap { 3dip } dip
} :4dip
"( w x y z q -- w x y z )\nremove w, x, y, and z from the stack. eval q. then restore w, x, y, and z to the stack"
@doc

{ over { eval } dip
} :keep
"( x q -- x )\napply q to x. then restore x to the stack"
@doc

{ { 2dup } dip 2dip
} :2keep
"( x y q -- x y )\napply q to x and y. then restore x and y to the stack"
@doc

{ { 3dup } dip 3dip
} :3keep
"( x y z q -- x y z )\napply q to x, y, and z. then restore x, y, and z to the stack"
@doc

{ { keep } dip eval
} :bi
"( x p q -- )\napply p to x. then apply q to x"
@doc

{ { 2keep } dip eval
} :2bi
"( x y p q -- )\napply p to x and y. then apply q to x and y"
@doc

{ { 3keep } dip eval
} :3bi
"( x y z p q -- )\napply p to x, y and z. then apply q to x, y, and z"
@doc

{ { { keep } dip keep } dip eval
} :tri
"( x p q r -- )\napply p to x. then apply q to x. then apply r to x"
@doc

{ { { 2keep } dip 2keep } dip eval
} :2tri
"( x y p q r -- )\napply p to x and y. then apply q to x and y. then apply r to x and y"
@doc

{ { { 3keep } dip 3keep } dip eval
} :3tri
"( x y z p q r -- )\napply p to x, y, and z. then apply q to x, y, and z. then apply r to x, y, and z"
@doc

{ { dip } dip eval
} :bi*
"( x y p q -- )\napply p to x. then apply q to y"
@doc

{ { 2dip } dip eval
} :2bi* @

{ { { 2dip } dip dip } dip eval
} :tri* @

{ { 4dip } 2dip 2bi*
} :2tri* @

{ dup bi*
} :bi^ @

{ dup 2bi*
} :2bi^ @

{ dup dup tri*
} :tri^ @

{ dup dup 2tri*
} :2tri^ @

{ bi^ and
} :both? @

{ bi^ or
} :either? @

; =====

{ ? eval } :if @
{ { } if } :when @
{ { } swap if } :unless @

{ 2dup slen 1 - >=
  { sget eval }
  { 2dup sget
    ; n arr branch
    0 swap sget 2dip
    ; #t/f n arr
    rot<
    { sget 1 swap sget eval }
    { { 1 + } dip cond' }
    if }
  if
} :cond'
; ( n slice -- )
@

{ 0 swap cond'
} :cond @


; TODO
; ?if
; case ?
;   cond is probably fine

; types ==

{ dup ffi-ptr?
  { dup record?
    { record-type-of }
    { ffi-type-of }
    if
    }
  ; TODO
  drop
  { ffi-type-of }
  { value-type-of }
  if
} :type-of @

{ value-type-of :int eq? } :int? @
{ value-type-of :float eq? } :float? @
{ value-type-of :char eq? } :char? @
{ value-type-of :boolean eq? } :boolean? @
{ value-type-of :sentinel eq? } :sentinel? @
{ value-type-of :string-literal eq? } :string-literal? @
{ value-type-of :word eq? } :word? @
{ value-type-of :symbol eq? } :symbol? @
{ value-type-of :slice eq? } :slice? @
{ value-type-of :ffi-fn eq? } :ffi-fn? @
{ value-type-of :ffi-ptr eq? } :ffi-ptr? @

{ dup ffi-ptr?
  { ffi-type-of :string eq? }
  { #f }
  if
} :string? @

{ dup ffi-ptr?
  { ffi-type-of :record eq? }
  { #f }
  if
} :record? @

{ dup ffi-ptr?
  { ffi-type-of :vec eq? }
  { #f }
  if
} :vec? @

{ dup ffi-ptr?
  { ffi-type-of :map eq? }
  { #f }
  if
} :map? @

; math ==

{ swap < } :> @
{ > not } :<= @
{ < not } :>= @

{ 2 mod 0 = } :even? @
{ even? not } :odd? @

{ { > } 2keep ? } :max @
{ { < } 2keep ? } :min @
{ min max } :clamp
"( min max val -- clamped )"
@doc

{ dup 0 < { neg } when
} :abs @

{ pick swap over { - } 2bi^
  swap mod +
} :wrap
"( min max val -- wrapped )"
@doc

; =====

; errors and optionals
; error:
;  ok-val  #t
;  err-val #f
; optional:
;  ok-val #t
;  #f     #f

; TODO get rid of this ?
; have unwrap that prints an error message before panic
{ { } { "panic" . panic } if
} :unwrap @

; val t/f def -- val or default
{ { swap } dip ?
} :unwrap,default @

;

; TODO for now this needs to be here because of unwrap
; fix that and move back up by eval
; :eval,restore' ref unwrap :eval,restore @
{ eval,restore' } :eval,restore @

; =====

{ vlen 0 swap
} :vbounds @

{ mget* drop
} :mget @

; TODO write in zig
{ <string>,clone string-append!
} :string-append @

; =====

#sentinel :[ @

{ over #sentinel eq? { nip } { { vpush! } keep ]vec' } if
} :]vec' @

{ <vec> ]vec' { vreverse! } keep
} :]vec
"( #sentinel ... a b c -- vec )"
@doc

{ over #sentinel eq? { nip } { { { swap } dip mset! } keep ]map' } if
} :]map' @

{ <map> ]map'
} :]map
"( #sentinel ... k1 v1 k2 v2 -- map )"
@doc

; slices ===

{ 2dup { slen } dip <=
  { 3drop #f #f }
  { 3dup swap sget eq?
    { 2nip #t }
    { 1 + index-of,eq' }
    if }
  if
} :index-of,eq'
; ( test slice n -- )
@

{ 0 index-of,eq'
} :index-of,eq @

; records ===

; TODO
;   autogenerate docstrings
;   lots of cleanup
;   display
;   eqv?

{ 0 swap rget
} :record-type-type @

{ 1 swap rget
} :record-type-name @

{ 2 swap rget
} :record-type-field-tags @

3 <record>
{ { downgrade } keep 0 swap rset! } keep
{ :record-type swap 1 swap rset! } keep
{ { :name :field-tags } swap 2 swap rset! } keep
:%record-type @

{ 3 <record>
  { { %record-type swap 0 swap rset! }
    { 1 swap rset! }
    { 2 swap rset! }
    tri } keep
} :<record-type> @

{ 0 swap rget
} :record-type-of @

{ record-type-of record-type-field-tags slen
} :record-field-ct @

{ record-type-of record-type-field-tags index-of,eq
} :record-field-index @

{ 2dup { record-field-ct } dip <=
  { drop }
  { { over record-field-ct swap - swap rset! } 2keep
    1 + construct' }
  if
} :construct'
; ( record n -- )
@

{ dup record-type-field-tags slen 1 + <record>
  { 0 swap rset! } keep
  0 construct'
} :construct @

{ record-type-of eq?
} :check-type @

{ { record-field-index unwrap 1 + } keep rset!
} :set-field! @

; def-record macros

{ dup symbol>string "%" string-append string>symbol { <record-type> } dip @
} :def-record'type @

{ nip
  :construct symbol>word swap
  symbol>string
  { "%" string-append string>symbol symbol>word }
  { "make-" string-append string>symbol }
  bi
  ; \construct \%cell :make-cell
  { <vec>
    { vpush! } keep
    { vpush! } keep
    vec>slice } dip
  @
} :def-record'constructor @

{ nip
  :eq? symbol>word swap
  symbol>string
  { "%" string-append string>symbol symbol>word }
  { "?" swap string-append string>symbol }
  bi
  :record-type-of symbol>word swap
  ; \eq? \%cell \record-type-of :cell?
  { <vec>
    { vpush! } keep
    { vpush! } keep
    { vpush! } keep
    vec>slice } dip
  @
} :def-record'predicate @

{ 2dup swap slen >=
  { 3drop }
  { 3dup
    { swap sget symbol>string swap string-append } keep
    1 +
    ; ... "type-field-name" n
    2dup
    ; getter
    { string>symbol :rget symbol>word :swap symbol>word } dip
    <vec>
    { vpush! } keep
    { vpush! } keep
    { vpush! } keep
    vec>slice
    swap
    @
    ; setter
    { "!" swap string-append string>symbol
      :rset! symbol>word :swap symbol>word } dip
    <vec>
    { vpush! } keep
    { vpush! } keep
    { vpush! } keep
    vec>slice
    swap
    @
    1 +
    def-record'accessors'
  }
  if
} :def-record'accessors'
; ( name-str field-names n -- )
@

{ symbol>string "-" swap string-append! swap 0 def-record'accessors'
} :def-record'accessors
; ( field-names symbol -- )
@

{ { def-record'type } 2keep
  { def-record'constructor } 2keep
  { def-record'predicate } 2keep
  def-record'accessors
} :@record
"( field-names symbol -- )"
@doc

; iterators =====

; iterators should always return 2 objects
; value/undefined #t/f

; TODO
;   chunks iterator
;     array>map for 'map literals'

{ :obj :check :next } :iterator @record
; :make-iterator ref unwrap :<iterator> @
{ make-iterator } :<iterator> @
{ dup iterator-check eval } :should-continue? @
{ dup iterator-next eval } :next! @

;

{ :val } :alwayser @record
{ make-alwayser
  { drop #t }
  { iterator-obj alwayser-val #t }
  <iterator>
} :always @

;

{ :iter :fn } :mapper @record
{ make-mapper
  { iterator-obj mapper-iter should-continue? }
  { dup should-continue?
    { iterator-obj
      { mapper-iter next! }
      { swap
        { mapper-fn eval #t }
        { drop #f }
        if }
      bi }
    { drop #f #f }
    if
    }
  <iterator>
} :map @

;

{ :iter :fn } :filterer @record
{ make-filterer
  { iterator-obj filterer-iter should-continue? }
  { dup should-continue?
    { iterator-obj
      { filterer-iter next! }
      { swap
        { { dup } dip filterer-fn eval #t }
        { drop #f #f }
        if }
      bi
      and
      }
    { drop #f #f }
    if
    }
  <iterator>
} :filter @

;

{ over should-continue?
  { { swap next!
      { swap eval }
      { drop }
      if
    } 2keep
    each! }
  { 2drop }
  if
} :each!
"( iter q -- )"
@doc

{ pick should-continue?
  { { over next! } dip
    swap
    { { eval } keep fold! }
    { nip fold! }
    if }
  { drop nip }
  if
} :fold!
"( iter acc fn -- )"
@doc

{ <vec> { over vpush! } fold! } :vcollect! @

;

; TODO fix zip

{ :first :second } :pair @record
; :make-pair ref unwrap :<pair> @
{ make-pair } :<pair> @

{ { pair-first } { pair-second } bi
} :pair>stack @

{ :a :b } :zipper @record

{ { zipper-a } { zipper-b } bi { should-continue? } both?
} :zipper-should-continue? @

{ make-zipper
  { iterator-obj zipper-should-continue? }
  { dup should-continue?
    { iterator-obj { zipper-a } { zipper-b } bi { next! } bi^
      { swap } dip and
      { <pair> #t }
      { 2drop #f #f }
      if }
    { drop #f #f }
    if
    }
  <iterator>
} :zip @

;

{ :inc :stop :acc } :counter @record

{ { counter-acc } { counter-stop } bi <
} :counter-should-continue? @

{ { { counter-acc } { counter-inc } bi + } keep counter-acc!
} :counter-increment! @

; TODO make sure inc != 0
; if you want to cound with floats, this 0 needs to be a float
{ 0 make-counter
  { iterator-obj counter-should-continue? }
  { dup should-continue?
    { iterator-obj { counter-acc } { counter-increment! } bi #t }
    { drop #f }
    if
    }
  <iterator>
} :count @

;

{ { 1 swap count } { always } bi*
  zip
} :sequence-iter
"( len seq -- iter )"
@doc

{ { slen } keep sequence-iter
  { pair>stack sget } map
} :slice-iter @

{ { vlen } keep sequence-iter
  { pair>stack vget } map
} :vec-iter @

{ { strlen } keep sequence-iter
  { pair>stack strget } map
} :string-iter @

{ stack-len { always } { 1 swap count } bi
  zip
  { pair>stack - 1 - } map
} :stack-iter @

; TODO write these in zig

{ slice-iter vcollect!
} :slice>vec @

{ string-iter vcollect!
} :string>vec @

; =====

{ :data :q } :callable @record

{ :saved-val :q } :curried @record

{ make-curried
  { { curried-saved-val } { curried-q eval } bi }
  make-callable
} :curry @

{ :p :q } :composed @record

{ make-composed
  { { composed-p eval } { composed-q eval } bi }
  make-callable
} :compose @

; =====

:in <file>,std unwrap :stdin @
:out <file>,std unwrap :stdout @
; TODO
; :err <file>,std unwrap :stderr @
