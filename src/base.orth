; todo add more documentation

<map> :doc-table @
{ doc-table mset! } :doc! @
{ doc-table mget* "docstring not found" unwrap,default } :doc @

{ over doc! @ } :@doc @
"( value symbol doc-string -- )\ndefine with a doc string" :@doc doc!

{ { symbol>string display } keep
  ": " display
  ; todo ref display should be ref write
  { ref display } keep newline
  doc display newline
} :.doc
"( symbol -- )\nprint documentation for a word"
@doc

{ ref eval
} :exec
"( symbol -- )\nevaluate a symbol"
@doc

; =====

{ "\n" display
} :newline
"( -- )\ndisplay a newline"
@doc

; =====

{ over over
} :2dup @

{ pick pick pick
} :3dup @

"( x -- )\npop a value off the stack" :drop doc!

{ drop drop
} :2drop
"( x y -- )\npop two values off the stack"
@doc

{ drop drop drop
} :3drop
"( x y z -- )\npop three values off the stack"
@doc

{ { drop } dip
} :nip
"( x y z -- x z )\nremove the second from the top value from the stack"
@doc

{ { 2drop } dip
} :2nip
"( x y z -- z )\nremove the second and third from the top values from the stack"
@doc

{ pick pick
} :2over @

{ { swap } dip swap
} :rot< @

{ swap { swap } dip
} :rot> @

; =====

"( x q -- x )\nremove x from the stack. eval q. then restore x to the stack" :dip doc!

{ swap { dip } dip
} :2dip
"( x y q -- x y )\nremove x and y from the stack. eval q. then restore x and y to the stack"
@doc

{ swap { 2dip } dip
} :3dip
"( x y z q -- x y z )\nremove x, y, and z from the stack. eval q. then restore x, y, and z to the stack"
@doc

{ swap { 3dip } dip
} :4dip
"( w x y z q -- w x y z )\nremove w, x, y, and z from the stack. eval q. then restore w, x, y, and z to the stack"
@doc

{ over { eval } dip
} :keep
"( x q -- x )\napply q to x. then restore x to the stack"
@doc

{ { 2dup } dip 2dip
} :2keep
"( x y q -- x y )\napply q to x and y. then restore x and y to the stack"
@doc

{ { 3dup } dip 3dip
} :3keep
"( x y z q -- x y z )\napply q to x, y, and z. then restore x, y, and z to the stack"
@doc

{ { keep } dip eval
} :bi
"( x p q -- )\napply p to x. then apply q to x"
@doc

{ { 2keep } dip eval
} :2bi
"( x y p q -- )\napply p to x and y. then apply q to x and y"
@doc

{ { 3keep } dip eval
} :3bi
"( x y z p q -- )\napply p to x, y and z. then apply q to x, y, and z"
@doc

{ { { keep } dip keep } dip eval
} :tri
"( x p q r -- )\napply p to x. then apply q to x. then apply r to x"
@doc

{ { { 2keep } dip 2keep } dip eval
} :2tri
"( x y p q r -- )\napply p to x and y. then apply q to x and y. then apply r to x and y"
@doc

{ { { 3keep } dip 3keep } dip eval
} :3tri
"( x y z p q r -- )\napply p to x, y, and z. then apply q to x, y, and z. then apply r to x, y, and z"
@doc

{ { dip } dip eval
} :bi*
"( x y p q -- )\napply p to x. then apply q to y"
@doc

{ { 2dip } dip eval
} :2bi* @

{ { { 2dip } dip dip } dip eval
} :tri* @

{ { 4dip } 2dip 2bi*
} :2tri* @

{ dup bi*
} :bi^ @

{ dup 2bi*
} :2bi^ @

{ dup dup tri*
} :tri^ @

{ dup dup 2tri*
} :2tri^ @

{ bi^ and
} :both? @

{ bi^ or
} :either? @

; =====

{ ? eval } :if @
{ { } if } :when @
{ { } swap if } :unless @

; TODO
; if* when* unless* ?if
; cond case

; types ==

{ dup ffi-ptr?
  { dup record?
    { record-type-of }
    { ffi-type-of }
    if
    }
  { value-type-of }
  if
} :type-of @

{ value-type-of :int eq? } :int? @
{ value-type-of :float eq? } :float? @
{ value-type-of :char eq? } :char? @
{ value-type-of :boolean eq? } :boolean? @
{ value-type-of :sentinel eq? } :sentinel? @
{ value-type-of :string-literal eq? } :string-literal? @
{ value-type-of :word eq? } :word? @
{ value-type-of :symbol eq? } :symbol? @
{ value-type-of :quotation-literal eq? } :quotation-literal? @
{ value-type-of :array-literal eq? } :array-literal? @
{ value-type-of :ffi-fn eq? } :ffi-fn? @
{ value-type-of :ffi-ptr eq? } :ffi-ptr? @

{ dup ffi-ptr?
  { ffi-type-of :string eq? }
  { #f }
  if
} :string? @

{ dup ffi-ptr?
  { ffi-type-of :record eq? }
  { #f }
  if
} :record? @

{ dup ffi-ptr?
  { ffi-type-of :vec eq? }
  { #f }
  if
} :vec? @

{ dup ffi-ptr?
  { ffi-type-of :map eq? }
  { #f }
  if
} :map? @

; math ==

{ swap < } :> @
{ > not } :<= @
{ < not } :>= @

{ 2 mod 0 = } :even? @
{ even? not } :odd? @

{ { > } 2keep ? } :max @
{ { < } 2keep ? } :min @
{ min max } :clamp
"( min max val -- clamped )"
@doc

{ dup 0 < { neg } when
} :abs @

{ pick swap over { - } 2bi^
  swap mod +
} :wrap
"( min max val -- wrapped )"
@doc

; =====

; errors and optionals
; error:
;  ok-val  #t
;  err-val #f
; optional:
;  ok-val #t
;  #f     #f

; TODO get rid of this
{ { } { "panic" . panic } if
} :unwrap @

; val t/f def -- val or default
{ { swap } dip ?
} :unwrap,default @

; =====

{ vlen 0 swap
} :vbounds @

{ mget* drop
} :mget @

; =====

#sentinel :[ @

{ over #sentinel eq? { nip } { { vpush! } keep ]vec' } if
} :]vec' @

{ <vec> ]vec' { vreverse! } keep
} :]vec
"( #sentinel ... a b c -- vec )"
@doc

{ over #sentinel eq? { nip } { { { swap } dip mset! } keep ]map' } if
} :]map' @

{ <map> ]map'
} :]map
" ( #sentinel ... k1 v1 k2 v2 -- map ) "
@doc

; iterators =====

; iterators should always return 2 objects
; value/undefined #t/f

; TODO
;   chunks iterator
;     array>map for 'map literals'

{ :obj :check :next }a :iterator @record
:make-iterator ref :<iterator> @
{ dup iterator-check eval } :should-continue? @
{ dup iterator-next eval } :next! @

;

{ :val }a :alwayser @record
{ make-alwayser
  { drop #t }
  { iterator-obj alwayser-val #t }
  <iterator>
} :always @

;

{ :iter :fn }a :mapper @record
{ make-mapper
  { iterator-obj mapper-iter should-continue? }
  { dup should-continue?
    { iterator-obj
      { mapper-iter next! }
      { swap
        { mapper-fn eval #t }
        { drop #f }
        if }
      bi }
    { drop #f #f }
    if
    }
  <iterator>
} :map @

;

{ :iter :fn }a :filterer @record
{ make-filterer
  { iterator-obj filterer-iter should-continue? }
  { dup should-continue?
    { iterator-obj
      { filterer-iter next! }
      { swap
        { { dup } dip filterer-fn eval #t }
        { drop #f #f }
        if }
      bi
      and
      }
    { drop #f #f }
    if
    }
  <iterator>
} :filter @

;

{ pick should-continue?
  { { over next! } dip
    swap
    { { eval } keep fold! }
    { nip fold! }
    if }
  { drop nip }
  if
} :fold! @

{ <vec> { over vpush! } fold! } :vcollect! @

;

{ :first :second }a :pair @record
:make-pair ref :<pair> @

{ :a :b }a :zipper @record

{ { zipper-a } { zipper-b } bi { should-continue? } both?
} :zipper-should-continue? @

{ make-zipper
  { iterator-obj zipper-should-continue? }
  { dup should-continue?
    { iterator-obj { zipper-a } { zipper-b } bi { next! } bi^
      { swap } dip and
      { <pair> #t }
      { 2drop #f #f }
      if }
    { drop #f #f }
    if
    }
  <iterator>
} :zip @

;

{ :vec :at }a :vec-iterator @record

{ { vec-iterator-at } { vec-iterator-vec } bi vget
} :vec-iterator-get-value @

{ { vec-iterator-at 1 + } { vec-iterator-at! } bi
} :vec-iterator-increment! @

{ 0 make-vec-iterator
  { iterator-obj { vec-iterator-at } { vec-iterator-vec vlen } bi < }
  { dup should-continue?
    { iterator-obj { vec-iterator-get-value } { vec-iterator-increment! } bi #t }
    { drop #f #f }
    if
    }
  <iterator>
} :vec-iter @

;

{ :str :at }a :string-iterator @record

{ { string-iterator-at } { string-iterator-str } bi sget
} :string-iterator-get-value @

{ { string-iterator-at 1 + } { string-iterator-at! } bi
} :string-iterator-increment! @

{ 0 make-string-iterator
  { iterator-obj { string-iterator-at } { string-iterator-str slen } bi < }
  { dup should-continue?
    { iterator-obj { string-iterator-get-value } { string-iterator-increment! } bi #t }
    { drop #f #f }
    if
    }
  <iterator>
} :string-iter @
