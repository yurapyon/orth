{ ref eval
} :exec @

; =====

{ drop drop
} :2drop @

{ drop drop drop
} :3drop @

{ { drop } dip
} :nip @

{ { 2drop } dip
} :2nip @

; =====

{ swap { dip } dip
} :2dip @

{ swap { 2dip } dip
} :3dip @

{ swap { 3dip } dip
} :4dip @

{ over { eval } dip
} :keep @

{ { 2dup } dip 2dip
} :2keep @

{ { 3dup } dip 3dip
} :3keep @

{ { keep } dip eval
} :bi @

{ { 2keep } dip eval
} :2bi @

{ { 3keep } dip eval
} :3bi @

{ { { keep } dip keep } dip eval
} :tri @

{ { { 2keep } dip 2keep } dip eval
} :2tri @

{ { { 3keep } dip 3keep } dip eval
} :3tri @

{ { dip } dip eval
} :bi* @

{ { 2dip } dip eval
} :2bi* @

{ { { 2dip } dip dip } dip eval
} :tri* @

{ { 4dip } 2dip 2bi*
} :2tri* @

{ dup bi*
} :bi^ @

{ dup 2bi*
} :2bi^ @

{ 2dup tri*
} :tri^ @

{ 2dup 2tri*
} :2tri^ @

{ bi^ and
} :both? @

{ bi^ or
} :either? @

; =====

{ ? eval } :if @
{ { } if } :when @
{ { } swap if } :unless @

; TODO
; if* when* unless* ?if
; cond case

; types ==

{ type-of :int eq? } :int? @
{ type-of :float eq? } :float? @
{ type-of :char eq? } :char? @
{ type-of :boolean eq? } :boolean? @
{ type-of :sentinel eq? } :sentinel? @
{ type-of :string eq? } :string? @
{ type-of :word eq? } :word? @
{ type-of :symbol eq? } :symbol? @
{ type-of :quotation eq? } :quotation? @
{ type-of :ffi-fn eq? } :ffi-fn? @
{ type-of :ffi-ptr eq? } :ffi-ptr? @

; math ==

{ swap < } :> @
{ > not } :<= @
{ < not } :>= @

{ { > } 2keep ? } :max @
{ { < } 2keep ? } :min @
{ min max } :clamp @

{ dup 0 < { neg } when
} :abs @

{ ; ( min max val -- wrapped )
pick swap over { - } 2bi^
swap mod +
} :wrap @

; =====

; errors and optionals
; error:
;  ok-val  #t
;  err-val #f
; optional:
;  ok-val #t
;  #f     #f

{ { } { "panic" . panic } if
} :unwrap @

; quotations ===

{ 0 swap qinsert!
} :qpush-front! @

{ <quotation>,clone
  { qpush-front! } keep
} :curry @

; =====

{ vlen 0 swap
} :vbounds @

{ mget* drop
} :mget @

; =====

#sentinel :[ @

{
over #sentinel eq? { nip } { { vpush! } keep ]vec' } if
} :]vec' @

{ ; ( #sentinel ... a b c -- vec )
<vec> ]vec' { vreverse! } keep
} :]vec @

{
over #sentinel eq? { nip } { { qpush! } keep ]q' } if
} :]q' @

{ ; ( #sentinel ... a b c -- vec )
<quotation> ]q' { qreverse! } keep
} :]q @

; TODO rewerite without return stack
{ dup #sentinel eq? { drop <R } { swap .R mset! ]map' } if
} :]map' @

{ ; ( #sentinel ... k1 v1 k2 v2 -- map )
<map> >R ]map'
} :]map @
